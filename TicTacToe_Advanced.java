/**
 * Advanced TicTacToe.
 * In this game, computer is the minimizer regarding the lowest result as its best choice.
 */

import java.util.Random;
import java.util.Scanner;

public class TicTacToe_Advanced {

    private static char USER = ' ';
    private static char COMPUTER = ' ';

    /**
     * Limit of 3 or 4 will generate results in acceptable time
     * Computing becomes faster while there are more points on the board
     */
    private static int COMPUTING_LIMIT = 4;

    private static int CONNECTION_CHECK = -90; // check if current board generates 3-point connection
    private static int ADJACENCY_CHECK = -60; // check if current board has adjacent (same) points connection

    /**
     * Evaluation Result = g_Value + h_Value, in which h stands for heuristic function
     * For advanced TicTacToe, consideration for future chain reactions in other boards needs more attention than just current 3 * 3 board,
     * so larger weight is assigned to the evaluation value generated by the heuristic function
     */
    private static double g_WEIGHT = 0.3;
    private static double h_WEIGHT = 0.7;

    private static boolean showEvaluationArray = false; // control whether displaying numeric evaluation results or not
    
    public static void main(String[] args){
        singleBoard[][] nineTTT_Board = new singleBoard[3][3];

        int cnt = 1;
        for (int i = 0; i < 3; i++) { // initialize all entries in the board as empty chars
            for (int j = 0; j < 3; j++) {
                nineTTT_Board[i][j] = new singleBoard();
                nineTTT_Board[i][j].boardID = cnt;
                cnt++;
            }
        }

        int boardID = 1;
        Position[] positionArr_nineBoard = new Position[10]; // 1 to 9, ignore entry 0 for latter convenience
        for (int i = 1; i < 10; i++) {
            positionArr_nineBoard[i] = new Position();
        }

        for (int i = 0; i < 3; i++) { //for outer 3 * 3 board
            for (int j = 0; j < 3; j++) {
                positionArr_nineBoard[boardID].row = i;
                positionArr_nineBoard[boardID].col = j;
                positionArr_nineBoard[boardID].ID = boardID;
                boardID++;
            }
        }

        int entryID = 1;
        Position[] positionArray = new Position[10];
        for (int i = 1; i < 10; i++) {
            positionArray[i] = new Position();
        }

        for (int i = 0; i < 3; i++) { // for inner 3 * 3 board
            for (int j = 0; j < 3; j++) {
                positionArray[entryID].row = i;
                positionArray[entryID].col = j;
                positionArray[entryID].ID = entryID;
                entryID++;
            }
        }

        char[][] display = new char[9][9]; // display the whole 9 * 9 board

        for(int i = 0; i < 9; i++){
            for (int j = 0; j < 9; j++) {
                display[i][j] = ' ';
            }
        }

        Scanner scan = new Scanner(System.in);

        do{
            System.out.print("Choose a character to play, X or O (Enter x for X, or o for O; Enter x to go first): ");
            USER = scan.next().charAt(0);
        }while(USER != 'x' && USER != 'o'); //input must be lower case x or o

        boolean computerFirst = false;

        //decide which player moves first, and switch all input characters to upper case
        if (USER == 'x') {
            USER = 'X';
            COMPUTER = 'O';
        }
        else {
            USER = 'O';
            COMPUTER = 'X';
            computerFirst = true;
        }

        int nextBoardID = 0;

        while (checkSpace( nineTTT_Board )) {

            if(computerFirst){ // if computer goes first

                /**
                 * Random position for computer's first move
                 *
                 * Random rand = new Random();
                 * int outterRow = rand.nextInt(3);
                 * int outterCol = rand.nextInt(3);
                 * int innerRow = rand.nextInt(3);
                 * int innerCol = rand.nextInt(3);
                 */

                // assigned position for computer's first move
                int outterRow = 1;
                int outterCol = 1;
                int innerRow = 0;
                int innerCol = 1;


                nineTTT_Board[outterRow][outterCol].board[innerRow][innerCol] = COMPUTER;

                int x = 3*outterRow + innerRow;
                int y = 3*outterCol + innerCol;
                display[x][y] = COMPUTER;
                printBoard(display);

                computerFirst = false;
                nextBoardID = nineTTT_Board[innerRow][innerCol].boardID;

            }

            int input1;
            if(nextBoardID!=0){
                System.out.print("You can now only place a move at board No." + nextBoardID); //prompt the user for input1
                System.out.println();
                input1 = nextBoardID;
            }

            else{
                do{
                    System.out.print("Please tell me your move(1st number): "); //prompt the user for input1
                    input1 = scan.nextInt();

                }while (input1 < 1 || input1 > 9 ); //check the move is legal
            }

            Position move1 = new Position();

            for (int i = 1; i < 10; i++) { //get the row and column of the user input1
                if (positionArr_nineBoard[i].ID == input1) {
                    move1.row = positionArr_nineBoard[i].row;
                    move1.col = positionArr_nineBoard[i].col;
                    break;
                }
            }

            int input2;
            do{
                System.out.print("Please tell me your move(2nd number): "); //prompt the user for input1
                input2 = scan.nextInt();

            }while (input2 < 1 || input2 > 9 ); //check the move is legal

            Position move2 = new Position();

            for (int i = 1; i < 10; i++) { //get the row and column of the user input2
                if (positionArray[i].ID == input2) {
                    move2.row = positionArray[i].row;
                    move2.col = positionArray[i].col;
                    break;
                }
            }

            int x1 = move1.row;
            int y1 = move1.col; // outer 3 * 3 block
            int x2 = move2.row;
            int y2 = move2.col; // inner 3 * 3, which decides next block assigned to the opponent

            int x = 3*x1 + x2;
            int y = 3*y1 + y2;
            display[x][y] = USER; // place it onto the display

            int next_x = 0; //decide the next 3 * 3 block assigned to the computer
            int next_y = 0;

            //nineTTT_Board[x1][y1].board[x2][y2] == ' ')
            if(nineTTT_Board[x1][y1].board[x2][y2] == ' '){ // check if move is acceptable

                /*char[][] board_USER = nineTTT_Board[x1][y1].board;
                board_USER[x2][y2] = USER;*/
                nineTTT_Board[x1][y1].board[x2][y2] = USER;

                char[][] board_COM = nineTTT_Board[x2][y2].board; //the board where computer is allowed to place a move: [x2][y2]

                if ( checkSpace_singleBoard(board_COM) ) {

                    //Position move_Computer = minimax(board_COM);
                    //board_COM[2][2]=COMPUTER;

                    /**
                     * Find the best move for computer
                     */
                    Position move_Computer = findBestMove(nineTTT_Board, x2,y2);

                    //Position move_Computer = findBestMove(nineTTT_Board[x2][y2].board);
                    //board_COM[move_Computer.row][move_Computer.col] = COMPUTER;

                    nineTTT_Board[x2][y2].board[move_Computer.row][move_Computer.col] = COMPUTER;

                    next_x = move_Computer.row;
                    next_y = move_Computer.col;

                    x = 3 * x2 + next_x;
                    y = 3 * y2 + next_y;
                    display[x][y] = COMPUTER;
                }


                printBoard(display);

                //constraint of next place

                int winner_indicator = getResult(nineTTT_Board);
                if (winner_indicator == 1) {
                    System.out.println("Congratulations! You win :)");
                    break;
                }

                if (winner_indicator == -1) {
                    System.out.println("The computer wins. Practice makes perfect");
                    break;
                }

                if (!checkSpace(nineTTT_Board)) { //board is full
                    System.out.println("It is a draw. Nobody wins.");
                    break;
                }
            }

            nextBoardID = nineTTT_Board[next_x][next_y].boardID; //get the next block to place move in
        }

        //System.out.println(move1.row + " " + move1.col); //test line
        //System.out.println(move2.row + " " + move2.col); //test line
    }

    private static Position findBestMove(singleBoard[][] nineTTT_Board, int x, int y){ //x2,y2 above; singleBoard[][] nineTTT_Board,

        singleBoard[][] temp = new singleBoard[3][3];
        for(int a=0;a < 3;a++){
            for(int b=0;b < 3;b++){
                temp[a][b] = nineTTT_Board[a][b]; // a copy of the nine-board (ohterwise original values will change in the function call)
            }
        }

        char[][] boardAI = temp[x][y].board;

        int alpha = (int) Double.NEGATIVE_INFINITY;
        int beta = (int) Double.POSITIVE_INFINITY;
        double[][] val = new double[3][3];

        for(int i = 0;i < 3;i++){
            for(int j = 0;j < 3;j++){
                if(boardAI[i][j] == ' '){

                    boardAI[i][j]=COMPUTER;

                    int g_Value = maxValue(boardAI,alpha,beta); // favor for the opponents

                    evalFunction(temp, i, j, 1, i, j, val); // evaluation starts from depth of 1

                    double h_Value = val[i][j];

                    val[i][j] = g_WEIGHT * g_Value + h_WEIGHT * h_Value; // assign weight to g_Value and h_Value

                    evalConnection(boardAI, val); // evaluate connection

                    val[i][j] += val[i][j]; // update the 3 * 3 entry evaluation value array after checking the connection

                    boardAI[i][j]=' ';

                }

            }
        }
        int row = 0;
        int col = 0;

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                val[i][j] += eval_OpponentConnection(i, j, nineTTT_Board); //evaluate the connection of opponents of the board he/she is sent to
            }
        }

        double[][] tmpValue = new double[3][3];
        boolean checkEquality = false;

        double min = Double.POSITIVE_INFINITY;
        for(int i = 0;i < 3;i++) {
            for (int j = 0; j < 3; j++) {

                if(boardAI[i][j]==' '){ //get minimum evaluation

                    if(val[i][j]< min){
                        min = val[i][j];
                        row = i;
                        col = j;
                    }
                    if(val[i][j]==min){
                        tmpValue[i][j] = val[i][j];
                        checkEquality = true;
                    }
                }
            }
        }

        if(checkEquality) {
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    if (tmpValue[i][j] != 0) {
                        tmpValue[i][j] += eval_OpponentConnection(i, j, temp);
                    }
                }
            }

            double newMIN = Double.POSITIVE_INFINITY;
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    if(tmpValue[i][j] < newMIN){
                        newMIN = tmpValue[i][j];
                        row = i;
                        col = j;
                    }
                }
            }
        }

        //possible to have multiple entries with the same minimum evaluation value
        //take the minimum that occurs first in the 3 * 3 evaluation results array traversal

        if(showEvaluationArray){
            print_singleBoard(val); // test line for showing evaluation value for each entry, but only the available ones will be processed later
        }

        Position p = new Position();
        p.row = row;
        p.col = col;
        return p;

    }

    // heuristic function (h) evaluates values in each entry in
    private static void evalFunction(singleBoard[][] nineTTT_Board, int x, int y, int depth, int index1, int index2, double[][] value){ //x : i, y : j

        singleBoard[][] tempTTT = new singleBoard[3][3];
        for(int a=0;a < 3;a++){
            for(int b=0;b < 3;b++){
                tempTTT[a][b] = nineTTT_Board[a][b]; // a copy of the nine-board
            }
        }

        if(depth == COMPUTING_LIMIT){
            return;
        }


        char[][] currentBoard = tempTTT[x][y].board;

        for(int i = 0;i < 3;i++) {
            for (int j = 0; j < 3; j++) {
                if (currentBoard[i][j] == ' ') {
                    currentBoard[i][j] = USER; // footprint need to be removed later

                    Position p = minimax(tempTTT[i][j].board); // minimax applied for the board AI is sent to

                    int xtmp = p.row;
                    int ytmp = p.col;
                    value[index1][index2] += p.backup_Value;
                    //evalConnection(tempTTT[i][j].board);

                    tempTTT[i][j].board[xtmp][ytmp] = COMPUTER;

                    evalFunction(tempTTT, xtmp, ytmp, depth + 1, index1, index2, value); // resursive till reaching the assigned computation limit

                    tempTTT[i][j].board[xtmp][ytmp]= ' ';
                    currentBoard[i][j] = ' ';
                }

            }
        }

    }


    private static Position minimax(char[][] board) { // MINIMAX with alpha-beta pruning

        int bestResult_Computer = (int) Double.POSITIVE_INFINITY;
        int alpha = (int) Double.NEGATIVE_INFINITY;
        int beta = (int) Double.POSITIVE_INFINITY;

        Position bestMove = new Position();

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (board[i][j] == ' ') { // move is accepted only when there is space in the target position

                    board[i][j] = COMPUTER;

                    int userResult = maxValue(board, alpha, beta);
                    //System.out.println(userResult); // test line

                    if(userResult < bestResult_Computer){ // find minimum value of the maximum values generated from user's results
                        bestResult_Computer = userResult;
                        bestMove.row = i;
                        bestMove.col = j;
                    }
                    board[i][j] = ' ';
                    //System.out.println(bestResult_Computer); // test line
                }
            }
        }
        bestMove.backup_Value = bestResult_Computer;
        return bestMove;
    }


    private static int maxValue(char[][] board, int alpha, int beta){

        int finalStateVal = getResult_singleBoard(board);
        if(finalStateVal == 1){
            return 10;
        }

        if(finalStateVal == -1){
            return -10;
        }

        if(!checkSpace_singleBoard(board)) { // board is full
            return 0;
        }

        int bestResult = (int)Double.NEGATIVE_INFINITY;

        //traverse the board
        for(int i = 0;i < 3;i++){
            for(int j = 0;j < 3;j++){
                if(board[i][j] == ' '){
                    board[i][j] = USER;

                    bestResult = Math.max(bestResult, minValue(board, alpha, beta));
                    board[i][j] = ' ';

                    if(bestResult > beta || bestResult == beta){ // pruning
                        return bestResult;
                    }
                    alpha = Math.max(alpha, bestResult);

                }
            }
        }
        return bestResult;

    }

    private static int minValue(char[][] board, int alpha, int beta){

        int finalStateVal = getResult_singleBoard(board);
        if(finalStateVal == 1){
            return 10;
        }

        if(finalStateVal == -1){
            return -10;
        }

        if(!checkSpace_singleBoard(board)) { // board is full
            return 0;
        }

        int bestResult = (int)Double.POSITIVE_INFINITY;
        for(int i = 0;i < 3;i++){
            for(int j = 0;j < 3;j++){
                if(board[i][j] == ' '){

                    board[i][j] = COMPUTER;
                    bestResult = Math.min(bestResult,maxValue(board, alpha, beta));
                    board[i][j] = ' ';

                    if(alpha > bestResult || alpha == bestResult){ // pruning
                        return bestResult;
                    }
                    beta = Math.min(beta, bestResult);

                }
            }
        }
        return bestResult;
    }

    private static boolean checkSpace(singleBoard[][] nineTTT_Board) { //check if there is still space on the all boards

        boolean check = false;
        for(int i = 0;i < 3;i++){
            for(int j = 0;j < 3;j++){
                check = checkSpace_singleBoard(nineTTT_Board[i][j].board);
            }
        }

        return check;
    }

    private static boolean checkSpace_singleBoard(char[][] board) { //check if there is still space on current 3*3 board

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                if (board[i][j] == ' ')
                    return true;
            }
        }

        return false;
    }

    private static int getResult(singleBoard[][] nineTTT_Board) {

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                char[][] board = nineTTT_Board[i][j].board;

                if(getResult_singleBoard(board) == 1){
                    return 1;
                } //return the result of checking each board
                else if(getResult_singleBoard(board) == -1){
                    return -1;
                }
            }
        }

        return 0; // 0 indicates no one wins and the game continues
    }

    private static int getResult_singleBoard(char[][] board){
        for (int row = 0; row < 3; row++) {
            if ((board[row][0] == board[row][1]) && (board[row][1] == board[row][2])) {
                if (board[row][0] == USER)
                    return 1;
                else if (board[row][0] == COMPUTER) {
                    return -1;
                }
            }
        }

        for (int col = 0; col < 3; col++) {
            if ((board[0][col] == board[1][col]) && (board[1][col] == board[2][col])) {
                if (board[0][col] == USER) {
                    return 1;
                } else if (board[0][col] == COMPUTER) {
                    return -1;
                }
            }
        }

        if ((board[0][0] == board[1][1]) && (board[1][1] == board[2][2])) {
            if (board[0][0] == USER) {
                return 1;
            } else if (board[0][0] == COMPUTER) {
                return -1;
            }
        }

        if ((board[0][2] == board[1][1]) && (board[1][1] == board[2][0])) {
            if (board[0][2] == USER) {
                return 1;
            } else if (board[0][2] == COMPUTER) {
                return -1;
            }
        }
        return 0; // 0 indicates no one wins and the game continues
    }


    private static void printBoard(char[][] display){
        for (int i = 0; i < 9; i++) {

            System.out.print("|");
            for (int j = 0; j < 3; j++) {
                System.out.print(display[i][j] + "|");
            }
            System.out.print("<>|");

            for (int j = 3; j < 6; j++) {
                System.out.print(display[i][j] + "|");
            }
            System.out.print("<>|");

            for (int j = 6; j < 9; j++) {
                System.out.print(display[i][j] + "|");
            }
            System.out.println();

            if(i==2 || i == 5){
                System.out.println();
            }
        }

    }

    private static void print_singleBoard(double[][] board){
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 3; j++) {
                System.out.print("|" + board[i][j]);
            }
            System.out.print("|");
            System.out.println();
            System.out.println("-------");
        }

    }

//    static void print_singleBoard(char[][] board){
//        for (int i = 0; i < 3; i++) {
//            for (int j = 0; j < 3; j++) {
//                System.out.print("|" + board[i][j]);
//            }
//            System.out.print("|");
//            System.out.println();
//            System.out.println("-------");
//        }
//
//    }

    private static void evalConnection(char[][] currentBoard, double[][] value){
//        int row = 0;
//        int col = 0;
        boolean[][] execute = new boolean[3][3];

        for(int i= 0;i<3;i++) {
            for (int j = 0; j < 3; j++) {
                execute[i][j] = true;
            }
        }

        for(int i= 0;i<3;i++){
            for(int j=0;j<3;j++){
                if(currentBoard[i][j] == COMPUTER){
                    if(i==0 && j==0){
                        if((currentBoard[0][0]==COMPUTER && currentBoard[0][1]==COMPUTER && currentBoard[0][2]==COMPUTER) ||
                                (currentBoard[0][0]==COMPUTER && currentBoard[1][0]==COMPUTER && currentBoard[2][0]==COMPUTER)||
                                (currentBoard[0][0]==COMPUTER && currentBoard[1][1]==COMPUTER && currentBoard[2][2]==COMPUTER)){
                            value[i][j] += CONNECTION_CHECK;
                            execute[i][j] = false;
                            //execute = false;
                        }
                        if(execute[i][j] && ((currentBoard[0][0]==COMPUTER && currentBoard[0][1]==COMPUTER) || (currentBoard[0][0]==COMPUTER && currentBoard[1][0]==COMPUTER))){
                            value[i][j] += ADJACENCY_CHECK;
                        }

                    }
                    if(i==0 && j==1){
                        if((currentBoard[0][0]==COMPUTER && currentBoard[0][1]==COMPUTER && currentBoard[0][2]==COMPUTER) ||
                                (currentBoard[0][1]==COMPUTER && currentBoard[1][1]==COMPUTER && currentBoard[2][1]==COMPUTER)){
                            value[i][j] += CONNECTION_CHECK;
                            execute[i][j] = false;
                        }
                        if(execute[i][j] && ((currentBoard[0][0]==COMPUTER && currentBoard[0][1]==COMPUTER) || (currentBoard[0][1]==COMPUTER && currentBoard[0][2]==COMPUTER)
                        || (currentBoard[0][1]==COMPUTER && currentBoard[1][1]==COMPUTER))){
                            value[i][j] += ADJACENCY_CHECK;
                        }

                    }
                    if(i==0 && j==2){
                        if((currentBoard[0][0]==COMPUTER && currentBoard[0][1]==COMPUTER && currentBoard[0][2]==COMPUTER) ||
                                (currentBoard[0][2]==COMPUTER && currentBoard[1][1]==COMPUTER && currentBoard[2][0]==COMPUTER)||
                                (currentBoard[0][2]==COMPUTER && currentBoard[1][2]==COMPUTER && currentBoard[2][2]==COMPUTER)){
                            value[i][j] += CONNECTION_CHECK;
                            execute[i][j] = false;
                        }
                        if(execute[i][j] && ((currentBoard[0][2]==COMPUTER && currentBoard[0][1]==COMPUTER) || (currentBoard[0][2]==COMPUTER && currentBoard[1][2]==COMPUTER))){
                            value[i][j] += ADJACENCY_CHECK;
                        }

                    }
                    if(i==1 && j==0){
                        if((currentBoard[1][0]==COMPUTER && currentBoard[1][1]==COMPUTER && currentBoard[1][2]==COMPUTER) ||
                                (currentBoard[0][0]==COMPUTER && currentBoard[1][0]==COMPUTER && currentBoard[2][0]==COMPUTER)){
                            value[i][j] += CONNECTION_CHECK;
                            execute[i][j] = false;
                        }
                        if(execute[i][j] && ((currentBoard[0][0]==COMPUTER && currentBoard[1][0]==COMPUTER) || (currentBoard[1][0]==COMPUTER && currentBoard[1][1]==COMPUTER)
                                || (currentBoard[1][0]==COMPUTER && currentBoard[2][0]==COMPUTER))){
                            value[i][j] += ADJACENCY_CHECK;
                        }

                    }
                    if(i==1 && j==1){
                        if((currentBoard[0][0]==COMPUTER && currentBoard[1][1]==COMPUTER && currentBoard[2][2]==COMPUTER) ||
                                (currentBoard[0][1]==COMPUTER && currentBoard[1][1]==COMPUTER && currentBoard[2][1]==COMPUTER)||
                                (currentBoard[0][2]==COMPUTER && currentBoard[1][1]==COMPUTER && currentBoard[2][0]==COMPUTER)||
                                (currentBoard[1][0]==COMPUTER && currentBoard[1][1]==COMPUTER && currentBoard[1][2]==COMPUTER)){
                            value[i][j] += CONNECTION_CHECK;
                            execute[i][j] = false;
                        }
                        if(execute[i][j] && ((currentBoard[1][1]==COMPUTER && currentBoard[0][1]==COMPUTER) || (currentBoard[1][1]==COMPUTER && currentBoard[1][0]==COMPUTER)
                                || (currentBoard[1][1]==COMPUTER && currentBoard[1][2]==COMPUTER) || (currentBoard[1][1]==COMPUTER && currentBoard[2][1]==COMPUTER))){
                            value[i][j] += ADJACENCY_CHECK;
                        }


                    }

                    if(i==1 && j==2){
                        if((currentBoard[0][2]==COMPUTER && currentBoard[1][2]==COMPUTER && currentBoard[2][2]==COMPUTER) ||
                                (currentBoard[1][0]==COMPUTER && currentBoard[1][1]==COMPUTER && currentBoard[1][2]==COMPUTER)
                                ){
                            value[i][j] += CONNECTION_CHECK;
                            execute[i][j] = false;
                        }
                        if(execute[i][j] && ((currentBoard[1][2]==COMPUTER && currentBoard[0][2]==COMPUTER) || (currentBoard[1][2]==COMPUTER && currentBoard[1][1]==COMPUTER)
                                || (currentBoard[1][1]==COMPUTER && currentBoard[2][2]==COMPUTER))){
                            value[i][j] += ADJACENCY_CHECK;
                        }
                    }

                    if(i==2 && j==0){
                        if((currentBoard[2][0]==COMPUTER && currentBoard[2][1]==COMPUTER && currentBoard[2][2]==COMPUTER) ||
                                (currentBoard[0][0]==COMPUTER && currentBoard[1][0]==COMPUTER && currentBoard[2][0]==COMPUTER) ||
                                (currentBoard[0][0]==COMPUTER && currentBoard[1][1]==COMPUTER && currentBoard[2][2]==COMPUTER)) {
                            value[i][j] += CONNECTION_CHECK;
                            execute[i][j] = false;
                        }
                        if(execute[i][j] && ((currentBoard[2][0]==COMPUTER && currentBoard[1][0]==COMPUTER) || (currentBoard[2][0]==COMPUTER && currentBoard[2][1]==COMPUTER))){
                            value[i][j] += ADJACENCY_CHECK;
                        }
                    }

                    if(i==2 && j==1){
                        if((currentBoard[2][0]==COMPUTER && currentBoard[2][1]==COMPUTER && currentBoard[2][2]==COMPUTER) ||
                                currentBoard[0][1]==COMPUTER && currentBoard[1][1]==COMPUTER && currentBoard[2][1]==COMPUTER){
                            value[i][j] += CONNECTION_CHECK;
                            execute[i][j] = false;
                        }
                        if(execute[i][j] && ((currentBoard[2][1]==COMPUTER && currentBoard[2][0]==COMPUTER) || (currentBoard[2][1]==COMPUTER && currentBoard[1][1]==COMPUTER)
                                || (currentBoard[2][1]==COMPUTER && currentBoard[2][2]==COMPUTER))){
                            value[i][j] += ADJACENCY_CHECK;
                        }

                    }
                    if(i==2 && j==2){
                        if((currentBoard[2][0]==COMPUTER && currentBoard[2][1]==COMPUTER && currentBoard[2][2]==COMPUTER) ||
                                (currentBoard[0][2]==COMPUTER && currentBoard[1][2]==COMPUTER && currentBoard[2][2]==COMPUTER) ||
                                (currentBoard[0][0]==COMPUTER && currentBoard[1][1]==COMPUTER && currentBoard[2][2]==COMPUTER)){
                            value[i][j] += CONNECTION_CHECK;
                            execute[i][j] = false;
                        }
                        if(execute[i][j] && ((currentBoard[2][2]==COMPUTER && currentBoard[2][1]==COMPUTER) || (currentBoard[2][2]==COMPUTER && currentBoard[1][2]==COMPUTER))){
                            value[i][j] += ADJACENCY_CHECK;
                        }
                    }

                }
            }
        }
    }

    private static double eval_OpponentConnection(int row, int col, singleBoard[][] nineTTT){ // evaluate opponent connections on each board to avoid sending opponent to the board where he/she will directly win in next step
        char[][] oppBoard = nineTTT[row][col].board;
        double num = 0.0;

        for(int i = 0;i < 3;i++) {
            int[] cnt = count_NoneEmptyEntry(oppBoard[i]);
            if(cnt[0] == 2 && cnt[1] == 1){
                num += 10000;
            }
        }

        for(int i = 0;i < 3;i++) {
            char[] COL = new char[]{oppBoard[0][i],oppBoard[1][i],oppBoard[2][i]};
            int[] cnt = count_NoneEmptyEntry(COL);
            if(cnt[0] == 2 && cnt[1] == 1){
                num += 10000;
            }
        }

        char[] diagnoal = new char[]{oppBoard[0][0],oppBoard[1][1],oppBoard[2][2]};
        int[] cnt = count_NoneEmptyEntry(diagnoal);
        if(cnt[0] == 2 && cnt[1] == 1){
            num += 10000;
        }

        diagnoal = new char[]{oppBoard[0][2],oppBoard[1][1],oppBoard[2][0]};
        cnt = count_NoneEmptyEntry(diagnoal);
        if(cnt[0] == 2 && cnt[1] == 1){
            num += 10000;
        }

        return num;
    }

    private static int[] count_NoneEmptyEntry(char[] arr){
        int[] cnt = new int[2];
        for(int i = 0;i < 3;i++){
            if(arr[i] == USER){
                cnt[0]++;
            }
            if(arr[i] == ' '){
                cnt[1]++;
            }

        }
        return cnt;
    }
}